# Router Specification

## Overview

The router maps directory paths to HTTP routes and dispatches requests to the correct Go handler function. Because Go is statically typed, the framework generates Go source code that imports each route package and registers handlers.

## File-based routing

The directory structure under the app root defines the URL paths:

```
example/
  dashboard/
    dashboard.go       -> GET /dashboard
    dashboard.tsx
  settings/
    settings.go        -> GET /settings
    settings.tsx
  users/
    profile/
      profile.go       -> GET /users/profile
      profile.tsx
```

The route path is the relative directory path from the app root.

## Generated server code

The framework generates a Go file that wires everything together. This is necessary because Go can't import packages or call functions dynamically at runtime.

Given the directory structure above, the framework generates:

```go
// Code generated by rstf. DO NOT EDIT.
package main

import (
    "encoding/json"
    "net/http"

    rstf "github.com/rafbgarcia/rstf"
    "github.com/rafbgarcia/rstf/internal/renderer"

    "github.com/rafbgarcia/example/dashboard"
    "github.com/rafbgarcia/example/settings"
    "github.com/rafbgarcia/example/users/profile"
)

func main() {
    r := renderer.New()

    http.HandleFunc("/dashboard", func(w http.ResponseWriter, req *http.Request) {
        ctx := rstf.NewContext(req)
        posts, author := dashboard.SSR(ctx)
        props := map[string]any{"posts": posts, "author": author}
        r.RenderSSR(w, "dashboard/dashboard", props)
    })

    http.HandleFunc("/settings", func(w http.ResponseWriter, req *http.Request) {
        ctx := rstf.NewContext(req)
        config, title := settings.SSR(ctx)
        props := map[string]any{"config": config, "title": title}
        r.RenderSSR(w, "settings/settings", props)
    })

    http.ListenAndServe(":3000", nil)
}
```

### Key details

- Each route handler calls the user's function with a `*rstf.Context`.
- Named return values are collected into a `map[string]any` — the keys match the Go param names, which match the generated TypeScript prop names.
- The map is passed to the renderer which serializes it to JSON for the Bun sidecar.
- If a function doesn't have `HasContext`, the generated code calls it without the context argument.

## How the codegen produces this

The `codegen` package already parses route directories and extracts:
- Package import path
- Function name (`SSR`, `GET`, etc.)
- Named return parameters
- Whether the function accepts `*rstf.Context`

A new `GenerateServer` function uses this information to produce the generated Go file. It needs:
- The module path of the user's app (from their `go.mod`)
- The parsed `[]RouteFile` from `ParseDir`

## Route matching

For the MVP, routing is simple path matching:
- Directory `dashboard/` → route `/dashboard`
- Nested directory `users/profile/` → route `/users/profile`
- No dynamic segments (`/users/:id`) in the MVP
- No query parameter parsing in the MVP

## Handler function dispatch

The framework recognizes these function names and maps them to HTTP methods:

| Go function | HTTP method | Behavior |
|-------------|-------------|----------|
| `SSR`       | GET         | Calls function, renders React component, returns HTML |
| `GET`       | GET         | Calls function, returns JSON (future) |
| `POST`      | POST        | Calls function, returns JSON (future) |
| `PUT`       | PUT         | Calls function, returns JSON (future) |
| `DELETE`    | DELETE      | Calls function, returns JSON (future) |

For the MVP, only `SSR` is implemented. The others will return JSON responses when added.

package codegen

import (
	"strings"
	"testing"
)

func TestGenerateServer_SingleRoute(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	expectations := []string{
		"// Code generated by rstf. DO NOT EDIT.",
		"package main",
		`"encoding/json"`,
		`"fmt"`,
		`"net/http"`,
		`"strings"`,
		`rstf "github.com/rafbgarcia/rstf"`,
		`"github.com/rafbgarcia/rstf/internal/renderer"`,
		`app "github.com/user/myapp"`,
		`dashboard "github.com/user/myapp/routes/dashboard"`,
		"func structToMap(v any) map[string]any {",
		"func assemblePage(html string, serverData map[string]map[string]any, bundlePath string) string {",
		"window.__RSTF_SERVER_DATA__",
		"func main() {",
		"r := renderer.New()",
		`r.Start(".")`,
		`http.Handle("GET /.rstf/static/"`,
		`http.HandleFunc("GET /dashboard"`,
		"ctx := rstf.NewContext(req)",
		`"main": structToMap(app.SSR(ctx))`,
		`"routes/dashboard": structToMap(dashboard.SSR(ctx))`,
		"sd := map[string]map[string]any{",
		"ServerData: sd,",
		`Component: "routes/dashboard"`,
		`Layout:    "main"`,
		`http.Error(w, err.Error(), 500)`,
		`assemblePage(html, sd, "/.rstf/static/dashboard/bundle.js")`,
		`http.ListenAndServe(":3000", nil)`,
	}

	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_MultipleRoutes(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/users.$id.edit",
			Package: "useredit",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/index":          {"routes/index"},
		"routes/dashboard":      {"routes/dashboard"},
		"routes/users.$id.edit": {"routes/users.$id.edit"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// Verify all three handlers exist.
	expectations := []string{
		`http.HandleFunc("GET /"`,
		`http.HandleFunc("GET /dashboard"`,
		`http.HandleFunc("GET /users/{id}/edit"`,
	}
	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}

	// Verify routes are sorted: / comes before /dashboard comes before /users/{id}/edit.
	idxRoot := strings.Index(got, `"GET /"`)
	idxDash := strings.Index(got, `"GET /dashboard"`)
	idxUser := strings.Index(got, `"GET /users/{id}/edit"`)
	if idxRoot >= idxDash || idxDash >= idxUser {
		t.Errorf("routes not sorted by URL pattern: / at %d, /dashboard at %d, /users/{id}/edit at %d", idxRoot, idxDash, idxUser)
	}

	// Verify bundle paths.
	bundleExpectations := []string{
		`"/.rstf/static/index/bundle.js"`,
		`"/.rstf/static/dashboard/bundle.js"`,
		`"/.rstf/static/users-id-edit/bundle.js"`,
	}
	for _, exp := range bundleExpectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing bundle path %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_SharedDeps(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "shared/ui/user-avatar",
			Package: "useravatar",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard", "shared/ui/user-avatar"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	expectations := []string{
		`useravatar "github.com/user/myapp/shared/ui/user-avatar"`,
		`"shared/ui/user-avatar": structToMap(useravatar.SSR(ctx))`,
	}
	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_RouteWithoutGoFile(t *testing.T) {
	// Route "about" has no .go file — only a .tsx. It should still get a handler
	// but with no route SSR call in ServerData.
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
	}
	deps := map[string][]string{
		"routes/about": {}, // no deps — the route has no .go, no shared deps with .go
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// Should still have a handler for /about.
	if !strings.Contains(got, `http.HandleFunc("GET /about"`) {
		t.Errorf("output missing handler for /about\n\nFull output:\n%s", got)
	}

	// Should have layout SSR but NOT a route SSR call.
	if !strings.Contains(got, `"main": structToMap(app.SSR(ctx))`) {
		t.Errorf("output missing layout SSR call\n\nFull output:\n%s", got)
	}

	// Should not contain "routes/about" as a ServerData key (it appears in Component, which is fine).
	if strings.Contains(got, `"routes/about": structToMap`) {
		t.Errorf("output should not contain routes/about ServerData entry\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_SSRWithoutContext(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: false}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: false}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// SSR calls should not pass ctx.
	if !strings.Contains(got, "structToMap(app.SSR())") {
		t.Errorf("expected app.SSR() without ctx\n\nFull output:\n%s", got)
	}
	if !strings.Contains(got, "structToMap(dashboard.SSR())") {
		t.Errorf("expected dashboard.SSR() without ctx\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_AliasCollision(t *testing.T) {
	// Two packages both named "index" — need unique aliases.
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/admin.index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/index":       {"routes/index"},
		"routes/admin.index": {"routes/admin.index"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// One should be "index", the other "index2".
	if !strings.Contains(got, `index "github.com/user/myapp/routes/index"`) {
		t.Errorf("expected index alias\n\nFull output:\n%s", got)
	}
	if !strings.Contains(got, `index2 "github.com/user/myapp/routes/admin.index"`) {
		t.Errorf("expected index2 alias for collision\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_NoLayout(t *testing.T) {
	// Edge case: no layout .go file. Should still generate handlers.
	files := []RouteFile{
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(got, `http.HandleFunc("GET /dashboard"`) {
		t.Errorf("output missing handler\n\nFull output:\n%s", got)
	}
	// Should NOT have layout import or SSR call.
	if strings.Contains(got, `app "github.com/user/myapp"`) {
		t.Errorf("should not have layout import\n\nFull output:\n%s", got)
	}
	if strings.Contains(got, `"main": structToMap`) {
		t.Errorf("should not have layout ServerData entry\n\nFull output:\n%s", got)
	}
}

func TestParseModulePath(t *testing.T) {
	tests := []struct {
		name    string
		content string
		want    string
	}{
		{
			name:    "standard",
			content: "module github.com/user/myapp\n\ngo 1.22\n",
			want:    "github.com/user/myapp",
		},
		{
			name:    "with extra whitespace",
			content: "  module   github.com/user/myapp  \n",
			want:    "github.com/user/myapp",
		},
		{
			name:    "no module line",
			content: "go 1.22\n",
			want:    "",
		},
		{
			name:    "commented out",
			content: "// module github.com/old\nmodule github.com/user/myapp\n",
			want:    "github.com/user/myapp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ParseModulePath([]byte(tt.content))
			if got != tt.want {
				t.Errorf("ParseModulePath() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGenerateServer_RejectsPackageMain(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "main",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	_, err := GenerateServer("github.com/user/myapp", files, deps)
	if err == nil {
		t.Fatal("expected error for package main in layout, got nil")
	}
	if !strings.Contains(err.Error(), "reserved for rstf") {
		t.Errorf("error should mention package main, got: %s", err)
	}
}

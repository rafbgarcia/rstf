package codegen

import (
	"encoding/json"
	"strings"
	"testing"
)

// assemblePage mirrors the generated assemblePage function from writeAssemblePage
// so we can unit-test the CSS link injection logic directly.
func assemblePage(html string, serverData map[string]map[string]any, bundlePath string, cssPath string) string {
	sdJSON, _ := json.Marshal(serverData)
	dataScript := "<script>window.__RSTF_SERVER_DATA__ = " + string(sdJSON) + "</script>"
	bundleScript := "<script src=\"" + bundlePath + "\"></script>"
	page := "<!DOCTYPE html>" + html
	if cssPath != "" {
		page = strings.Replace(page, "</head>", "<link rel=\"stylesheet\" href=\""+cssPath+"\">\n</head>", 1)
	}
	page = strings.Replace(page, "</body>", dataScript+bundleScript+"</body>", 1)
	return page
}

func TestAssemblePage_WithCSS(t *testing.T) {
	html := "<html><head><title>Test</title></head><body><h1>Hello</h1></body></html>"
	sd := map[string]map[string]any{"main": {"key": "val"}}
	cssPath := "/.rstf/static/main.css"

	got := assemblePage(html, sd, "/.rstf/static/dashboard/bundle.js", cssPath)

	checks := []struct {
		desc string
		want string
	}{
		{"doctype", "<!DOCTYPE html>"},
		{"css link tag", `<link rel="stylesheet" href="/.rstf/static/main.css">`},
		{"css before </head>", `main.css">` + "\n</head>"},
		{"data script", `window.__RSTF_SERVER_DATA__`},
		{"bundle script", `<script src="/.rstf/static/dashboard/bundle.js"></script>`},
	}
	for _, c := range checks {
		if !strings.Contains(got, c.want) {
			t.Errorf("%s: output missing %q\n\nFull output:\n%s", c.desc, c.want, got)
		}
	}

	// CSS link must appear before </head>, not in the body.
	linkIdx := strings.Index(got, `<link rel="stylesheet"`)
	headIdx := strings.Index(got, "</head>")
	bodyIdx := strings.Index(got, "<body>")
	if linkIdx > headIdx {
		t.Errorf("CSS link should appear before </head>")
	}
	if linkIdx > bodyIdx {
		t.Errorf("CSS link should appear before <body>")
	}
}

func TestAssemblePage_WithoutCSS(t *testing.T) {
	html := "<html><head><title>Test</title></head><body><h1>Hello</h1></body></html>"
	sd := map[string]map[string]any{"main": {"key": "val"}}

	got := assemblePage(html, sd, "/.rstf/static/dashboard/bundle.js", "")

	if strings.Contains(got, "<link") {
		t.Errorf("should not contain <link> tag when cssPath is empty\n\nFull output:\n%s", got)
	}

	// Should still have doctype and scripts.
	for _, want := range []string{"<!DOCTYPE html>", "window.__RSTF_SERVER_DATA__", `<script src="`} {
		if !strings.Contains(got, want) {
			t.Errorf("output missing %q\n\nFull output:\n%s", want, got)
		}
	}
}

func TestGenerateServer_SingleRoute(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	expectations := []string{
		"// Code generated by rstf. DO NOT EDIT.",
		"package main",
		`"encoding/json"`,
		`"flag"`,
		`"fmt"`,
		`"net/http"`,
		`"os"`,
		`"os/signal"`,
		`"strings"`,
		`"syscall"`,
		`rstf "github.com/rafbgarcia/rstf"`,
		`"github.com/rafbgarcia/rstf/renderer"`,
		`"github.com/rafbgarcia/rstf/router"`,
		`app "github.com/user/myapp"`,
		`dashboard "github.com/user/myapp/routes/dashboard"`,
		"func structToMap(v any) map[string]any {",
		"func assemblePage(html string, serverData map[string]map[string]any, bundlePath string, cssPath string) string {",
		"window.__RSTF_SERVER_DATA__",
		"func main() {",
		"r := renderer.New()",
		`if err := r.Start("."); err != nil`,
		`defer r.Stop()`,
		`signal.Notify(c, os.Interrupt, syscall.SIGTERM)`,
		`rt := router.New()`,
		`rt.Handle("/.rstf/static/*"`,
		`rt.Get("/dashboard"`,
		"ctx := rstf.NewContext(req)",
		`"main": structToMap(app.SSR(ctx))`,
		`"routes/dashboard": structToMap(dashboard.SSR(ctx))`,
		"sd := map[string]map[string]any{",
		"ServerData: sd,",
		`Component: "routes/dashboard"`,
		`Layout:    "main"`,
		`http.Error(w, err.Error(), 500)`,
		`assemblePage(html, sd, "/.rstf/static/dashboard/bundle.js", cssPath)`,
		`os.Stat(".rstf/static/main.css")`,
		`flag.String("port", "3000", "HTTP server port")`,
		`flag.Parse()`,
		`http.ListenAndServe(":"+*port, rt)`,
	}

	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_MultipleRoutes(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/users.$id.edit",
			Package: "useredit",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/index":          {"routes/index"},
		"routes/dashboard":      {"routes/dashboard"},
		"routes/users.$id.edit": {"routes/users.$id.edit"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// Verify all three handlers exist.
	expectations := []string{
		`rt.Get("/"`,
		`rt.Get("/dashboard"`,
		`rt.Get("/users/{id}/edit"`,
		// Dynamic route should use .rstf/pkgs/ symlink path ($ stripped).
		`useredit "github.com/user/myapp/.rstf/pkgs/routes/users.id.edit"`,
	}
	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}

	// Non-dynamic routes should NOT use the pkgs path.
	if strings.Contains(got, `.rstf/pkgs/routes/dashboard`) {
		t.Errorf("non-dynamic route should not use .rstf/pkgs path\n\nFull output:\n%s", got)
	}

	// Verify routes are sorted: / comes before /dashboard comes before /users/{id}/edit.
	idxRoot := strings.Index(got, `rt.Get("/"`)
	idxDash := strings.Index(got, `rt.Get("/dashboard"`)
	idxUser := strings.Index(got, `rt.Get("/users/{id}/edit"`)
	if idxRoot >= idxDash || idxDash >= idxUser {
		t.Errorf("routes not sorted by URL pattern: / at %d, /dashboard at %d, /users/{id}/edit at %d", idxRoot, idxDash, idxUser)
	}

	// Verify bundle paths.
	bundleExpectations := []string{
		`"/.rstf/static/index/bundle.js"`,
		`"/.rstf/static/dashboard/bundle.js"`,
		`"/.rstf/static/users-id-edit/bundle.js"`,
	}
	for _, exp := range bundleExpectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing bundle path %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_SharedDeps(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "shared/ui/user-avatar",
			Package: "useravatar",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard", "shared/ui/user-avatar"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	expectations := []string{
		`useravatar "github.com/user/myapp/shared/ui/user-avatar"`,
		`"shared/ui/user-avatar": structToMap(useravatar.SSR(ctx))`,
	}
	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateServer_RouteWithoutGoFile(t *testing.T) {
	// Route "about" has no .go file — only a .tsx. It should still get a handler
	// but with no route SSR call in ServerData.
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
	}
	deps := map[string][]string{
		"routes/about": {}, // no deps — the route has no .go, no shared deps with .go
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// Should still have a handler for /about.
	if !strings.Contains(got, `rt.Get("/about"`) {
		t.Errorf("output missing handler for /about\n\nFull output:\n%s", got)
	}

	// Should have layout SSR but NOT a route SSR call.
	if !strings.Contains(got, `"main": structToMap(app.SSR(ctx))`) {
		t.Errorf("output missing layout SSR call\n\nFull output:\n%s", got)
	}

	// Should not contain "routes/about" as a ServerData key (it appears in Component, which is fine).
	if strings.Contains(got, `"routes/about": structToMap`) {
		t.Errorf("output should not contain routes/about ServerData entry\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_SSRWithoutContext(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: false}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: false}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// SSR calls should not pass ctx.
	if !strings.Contains(got, "structToMap(app.SSR())") {
		t.Errorf("expected app.SSR() without ctx\n\nFull output:\n%s", got)
	}
	if !strings.Contains(got, "structToMap(dashboard.SSR())") {
		t.Errorf("expected dashboard.SSR() without ctx\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_AliasCollision(t *testing.T) {
	// Two packages both named "index" — need unique aliases.
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "myapp",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
		{
			Dir:     "routes/admin.index",
			Package: "index",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/index":       {"routes/index"},
		"routes/admin.index": {"routes/admin.index"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	// One should be "index", the other "index2".
	if !strings.Contains(got, `index "github.com/user/myapp/routes/index"`) {
		t.Errorf("expected index alias\n\nFull output:\n%s", got)
	}
	if !strings.Contains(got, `index2 "github.com/user/myapp/routes/admin.index"`) {
		t.Errorf("expected index2 alias for collision\n\nFull output:\n%s", got)
	}
}

func TestGenerateServer_NoLayout(t *testing.T) {
	// Edge case: no layout .go file. Should still generate handlers.
	files := []RouteFile{
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	got, err := GenerateServer("github.com/user/myapp", files, deps)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(got, `rt.Get("/dashboard"`) {
		t.Errorf("output missing handler\n\nFull output:\n%s", got)
	}
	// Should NOT have layout import or SSR call.
	if strings.Contains(got, `app "github.com/user/myapp"`) {
		t.Errorf("should not have layout import\n\nFull output:\n%s", got)
	}
	if strings.Contains(got, `"main": structToMap`) {
		t.Errorf("should not have layout ServerData entry\n\nFull output:\n%s", got)
	}
}

func TestParseModulePath(t *testing.T) {
	tests := []struct {
		name    string
		content string
		want    string
	}{
		{
			name:    "standard",
			content: "module github.com/user/myapp\n\ngo 1.22\n",
			want:    "github.com/user/myapp",
		},
		{
			name:    "with extra whitespace",
			content: "  module   github.com/user/myapp  \n",
			want:    "github.com/user/myapp",
		},
		{
			name:    "no module line",
			content: "go 1.22\n",
			want:    "",
		},
		{
			name:    "commented out",
			content: "// module github.com/old\nmodule github.com/user/myapp\n",
			want:    "github.com/user/myapp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ParseModulePath([]byte(tt.content))
			if got != tt.want {
				t.Errorf("ParseModulePath() = %q, want %q", got, tt.want)
			}
		})
	}
}

func TestGenerateServer_RejectsPackageMain(t *testing.T) {
	files := []RouteFile{
		{
			Dir:     ".",
			Package: "main",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "Session", HasContext: true}},
			Structs: []StructDef{{Name: "Session"}},
		},
		{
			Dir:     "routes/dashboard",
			Package: "dashboard",
			Funcs:   []RouteFunc{{Name: "SSR", ReturnType: "ServerData", HasContext: true}},
			Structs: []StructDef{{Name: "ServerData"}},
		},
	}
	deps := map[string][]string{
		"routes/dashboard": {"routes/dashboard"},
	}

	_, err := GenerateServer("github.com/user/myapp", files, deps)
	if err == nil {
		t.Fatal("expected error for package main in layout, got nil")
	}
	if !strings.Contains(err.Error(), "reserved for rstf") {
		t.Errorf("error should mention package main, got: %s", err)
	}
}

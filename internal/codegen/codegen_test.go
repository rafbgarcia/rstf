package codegen

import (
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"testing"
)

func testdataDir() string {
	_, file, _, _ := runtime.Caller(0)
	return filepath.Join(filepath.Dir(file), "testdata")
}

func TestParseDir(t *testing.T) {
	routes, err := ParseDir(testdataDir())
	if err != nil {
		t.Fatalf("ParseDir: %v", err)
	}

	// Sort for deterministic order.
	sort.Slice(routes, func(i, j int) bool {
		return routes[i].Dir < routes[j].Dir
	})

	if len(routes) != 2 {
		t.Fatalf("expected 2 route dirs, got %d", len(routes))
	}

	t.Run("dashboard route", func(t *testing.T) {
		rf := routes[0]
		if rf.Dir != "dashboard" {
			t.Errorf("expected dir=dashboard, got %s", rf.Dir)
		}
		if rf.Package != "dashboard" {
			t.Errorf("expected package=dashboard, got %s", rf.Package)
		}
		if len(rf.Funcs) != 1 {
			t.Fatalf("expected 1 func, got %d", len(rf.Funcs))
		}

		fn := rf.Funcs[0]
		if fn.Name != "SSR" {
			t.Errorf("expected func name=SSR, got %s", fn.Name)
		}
		if !fn.HasContext {
			t.Error("expected HasContext=true")
		}
		if len(fn.Params) != 2 {
			t.Fatalf("expected 2 params, got %d", len(fn.Params))
		}

		// posts []Post
		p := fn.Params[0]
		if p.Name != "posts" || p.Type != "Post" || !p.IsSlice {
			t.Errorf("param 0: got %+v", p)
		}

		// author Author
		p = fn.Params[1]
		if p.Name != "author" || p.Type != "Author" || p.IsSlice {
			t.Errorf("param 1: got %+v", p)
		}

		// Structs: Post and Author
		if len(rf.Structs) != 2 {
			t.Fatalf("expected 2 structs, got %d", len(rf.Structs))
		}
	})

	t.Run("settings route", func(t *testing.T) {
		rf := routes[1]
		if rf.Dir != "settings" {
			t.Errorf("expected dir=settings, got %s", rf.Dir)
		}
		if len(rf.Funcs) != 1 {
			t.Fatalf("expected 1 func, got %d", len(rf.Funcs))
		}

		fn := rf.Funcs[0]
		if !fn.HasContext {
			t.Error("expected HasContext=true")
		}
		if len(fn.Params) != 2 {
			t.Fatalf("expected 2 params, got %d", len(fn.Params))
		}

		// config Config (non-primitive, non-slice)
		p := fn.Params[0]
		if p.Name != "config" || p.Type != "Config" || p.IsSlice {
			t.Errorf("param 0: got %+v", p)
		}

		// title string (primitive)
		p = fn.Params[1]
		if p.Name != "title" || p.Type != "string" || p.IsSlice {
			t.Errorf("param 1: got %+v", p)
		}
	})
}

func TestGenerateDTS_Dashboard(t *testing.T) {
	rf := RouteFile{
		Dir:     "dashboard",
		Package: "dashboard",
		Funcs: []RouteFunc{
			{
				Name: "SSR",
				Params: []RouteParam{
					{Name: "posts", Type: "Post", IsSlice: true},
					{Name: "author", Type: "Author", IsSlice: false},
				},
			},
		},
		Structs: []StructDef{
			{
				Name: "Post",
				Fields: []StructField{
					{Name: "Title", JSONName: "title", Type: "string"},
					{Name: "Published", JSONName: "published", Type: "boolean"},
				},
			},
			{
				Name: "Author",
				Fields: []StructField{
					{Name: "Name", JSONName: "name", Type: "string"},
					{Name: "Email", JSONName: "email", Type: "string"},
				},
			},
		},
	}

	got := GenerateDTS(rf)

	expectations := []string{
		"// Code generated by rstf. DO NOT EDIT.",
		"declare namespace Dashboard {",
		"  interface Post {",
		"    title: string;",
		"    published: boolean;",
		"  interface Author {",
		"    name: string;",
		"    email: string;",
		"  interface SSRProps {",
		"    posts: Post[];",
		"    author: Author;",
	}

	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateDTS_PrimitiveTypes(t *testing.T) {
	rf := RouteFile{
		Dir:     "settings",
		Package: "settings",
		Funcs: []RouteFunc{
			{
				Name: "SSR",
				Params: []RouteParam{
					{Name: "config", Type: "Config", IsSlice: false},
					{Name: "title", Type: "string", IsSlice: false},
				},
			},
		},
		Structs: []StructDef{
			{
				Name: "Config",
				Fields: []StructField{
					{Name: "Theme", JSONName: "theme", Type: "string"},
					{Name: "FontSize", JSONName: "fontSize", Type: "number"},
					{Name: "Beta", JSONName: "beta", Type: "boolean"},
					{Name: "Score", JSONName: "score", Type: "number"},
				},
			},
		},
	}

	got := GenerateDTS(rf)

	expectations := []string{
		"declare namespace Settings {",
		"  interface Config {",
		"    theme: string;",
		"    fontSize: number;",
		"    beta: boolean;",
		"    score: number;",
		"  interface SSRProps {",
		"    config: Config;",
		"    title: string;",
	}

	for _, exp := range expectations {
		if !strings.Contains(got, exp) {
			t.Errorf("output missing %q\n\nFull output:\n%s", exp, got)
		}
	}
}

func TestGenerateDTS_NestedRoute(t *testing.T) {
	rf := RouteFile{
		Dir:     "users/profile",
		Package: "profile",
		Funcs: []RouteFunc{
			{
				Name:   "SSR",
				Params: []RouteParam{{Name: "name", Type: "string", IsSlice: false}},
			},
		},
	}

	got := GenerateDTS(rf)

	if !strings.Contains(got, "declare namespace UsersProfile {") {
		t.Errorf("expected namespace UsersProfile, got:\n%s", got)
	}
}

func TestNamespace(t *testing.T) {
	tests := []struct {
		dir  string
		want string
	}{
		{"dashboard", "Dashboard"},
		{"settings", "Settings"},
		{"users/profile", "UsersProfile"},
		{"admin/users/edit", "AdminUsersEdit"},
	}
	for _, tt := range tests {
		got := Namespace(tt.dir)
		if got != tt.want {
			t.Errorf("Namespace(%q) = %q, want %q", tt.dir, got, tt.want)
		}
	}
}

func TestGoTypeToTS(t *testing.T) {
	tests := []struct {
		goType  string
		isSlice bool
		want    string
	}{
		{"string", false, "string"},
		{"int", false, "number"},
		{"int64", false, "number"},
		{"float64", false, "number"},
		{"bool", false, "boolean"},
		{"Post", false, "Post"},
		{"string", true, "string[]"},
		{"Post", true, "Post[]"},
		{"uint32", false, "number"},
	}

	for _, tt := range tests {
		got := goTypeToTS(tt.goType, tt.isSlice)
		if got != tt.want {
			t.Errorf("goTypeToTS(%q, %v) = %q, want %q", tt.goType, tt.isSlice, got, tt.want)
		}
	}
}

func TestJsonTagName(t *testing.T) {
	routes, err := ParseDir(testdataDir())
	if err != nil {
		t.Fatalf("ParseDir: %v", err)
	}

	var dashboard *RouteFile
	for i := range routes {
		if routes[i].Dir == "dashboard" {
			dashboard = &routes[i]
			break
		}
	}
	if dashboard == nil {
		t.Fatal("dashboard route not found")
	}

	var post *StructDef
	for i := range dashboard.Structs {
		if dashboard.Structs[i].Name == "Post" {
			post = &dashboard.Structs[i]
			break
		}
	}
	if post == nil {
		t.Fatal("Post struct not found")
	}

	if len(post.Fields) != 2 {
		t.Fatalf("expected 2 fields, got %d", len(post.Fields))
	}
	if post.Fields[0].JSONName != "title" {
		t.Errorf("field 0 jsonName: got %q, want %q", post.Fields[0].JSONName, "title")
	}
	if post.Fields[1].JSONName != "published" {
		t.Errorf("field 1 jsonName: got %q, want %q", post.Fields[1].JSONName, "published")
	}
}

func TestParseDirSkipsNonRouteFiles(t *testing.T) {
	dir := t.TempDir()
	writeFile(t, filepath.Join(dir, "helpers", "helpers.go"), `
package helpers

func DoSomething() string {
	return "hi"
}
`)

	routes, err := ParseDir(dir)
	if err != nil {
		t.Fatalf("ParseDir: %v", err)
	}
	if len(routes) != 0 {
		t.Errorf("expected 0 routes, got %d", len(routes))
	}
}

func TestParseDirNoContext(t *testing.T) {
	dir := t.TempDir()
	writeFile(t, filepath.Join(dir, "page", "page.go"), `
package page

type Item struct {
	Name string `+"`json:\"name\"`"+`
}

func SSR() (items []Item) {
	return
}
`)

	routes, err := ParseDir(dir)
	if err != nil {
		t.Fatalf("ParseDir: %v", err)
	}
	if len(routes) != 1 {
		t.Fatalf("expected 1 route, got %d", len(routes))
	}
	fn := routes[0].Funcs[0]
	if fn.HasContext {
		t.Error("expected HasContext=false for function without context param")
	}
	if len(fn.Params) != 1 {
		t.Fatalf("expected 1 param, got %d", len(fn.Params))
	}
}

func TestParseDirSkipsUnnamedReturns(t *testing.T) {
	dir := t.TempDir()
	writeFile(t, filepath.Join(dir, "api", "api.go"), `
package api

type Result struct {
	Value string `+"`json:\"value\"`"+`
}

func GET() Result {
	return Result{Value: "test"}
}
`)

	routes, err := ParseDir(dir)
	if err != nil {
		t.Fatalf("ParseDir: %v", err)
	}
	// GET() returns Result without a name â€” should be skipped.
	if len(routes) != 0 {
		t.Errorf("expected 0 routes (unnamed return), got %d", len(routes))
	}
}

func writeFile(t *testing.T, path, content string) {
	t.Helper()
	err := os.MkdirAll(filepath.Dir(path), 0o755)
	if err != nil {
		t.Fatalf("mkdir %s: %v", filepath.Dir(path), err)
	}
	err = os.WriteFile(path, []byte(content), 0o644)
	if err != nil {
		t.Fatalf("writing %s: %v", path, err)
	}
}

package codegen

import (
	"fmt"
	"path/filepath"
	"strings"
	"unicode"
)

// Namespace returns the PascalCase namespace name for a route directory path.
// Examples: "dashboard" -> "Dashboard", "users/profile" -> "UsersProfile",
// "auth/forgot-password" -> "AuthForgotPassword"
func Namespace(dir string) string {
	if dir == "." {
		return "Main"
	}
	parts := strings.Split(filepath.ToSlash(dir), "/")
	var result strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		for _, seg := range strings.FieldsFunc(part, func(r rune) bool {
			return !unicode.IsLetter(r) && !unicode.IsDigit(r)
		}) {
			result.WriteString(ucFirst(seg))
		}
	}
	return result.String()
}

// GenerateDTS produces a TypeScript declaration file (.d.ts) with a declare namespace
// for a parsed RouteFile. The types are globally available without imports.
func GenerateDTS(rf RouteFile) string {
	ns := Namespace(rf.Dir)
	var b strings.Builder
	b.WriteString("// Code generated by rstf. DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "declare namespace %s {\n", ns)

	// Write interfaces for each struct (including the ServerData return type).
	for i, sd := range rf.Structs {
		fmt.Fprintf(&b, "  interface %s {\n", sd.Name)
		for _, f := range sd.Fields {
			fmt.Fprintf(&b, "    %s: %s;\n", f.JSONName, f.Type)
		}
		b.WriteString("  }\n")
		if i < len(rf.Structs)-1 {
			b.WriteString("\n")
		}
	}

	b.WriteString("}\n")
	return b.String()
}

// GenerateRuntimeModule produces the .rstf/generated/{path}.ts module that exports
// a serverData() function and an internal __setServerData() function.
//
// The module is dual-mode: on the server, _data starts empty and is set by
// __setServerData() before each render. On the client, _data is initialized
// from window.__RSTF_SERVER_DATA__[componentPath] at import time.
//
// componentPath is the key used in __RSTF_SERVER_DATA__ (e.g. "main",
// "routes/dashboard", "shared/ui/user-avatar").
func GenerateRuntimeModule(rf RouteFile, componentPath string) string {
	if len(rf.Funcs) == 0 {
		return ""
	}

	fn := rf.Funcs[0]
	ns := Namespace(rf.Dir)

	// Verify the return struct exists.
	found := false
	for _, s := range rf.Structs {
		if s.Name == fn.ReturnType {
			found = true
			break
		}
	}
	if !found {
		return ""
	}

	var b strings.Builder
	b.WriteString("// Code generated by rstf. DO NOT EDIT.\n")

	// Dual-mode initialization: server gets empty object, client reads from
	// the serialized data embedded in the HTML by the Go server.
	b.WriteString("let _data: Record<string, any> =\n")
	b.WriteString("  typeof window !== \"undefined\"\n")
	fmt.Fprintf(&b, "    ? (window as any).__RSTF_SERVER_DATA__[%q] ?? {}\n", componentPath)
	b.WriteString("    : {};\n\n")

	// serverData() function â€” returns _data directly. The Go side always
	// provides complete data via json.Marshal, so all fields are present.
	fmt.Fprintf(&b, "export function serverData(): %s.%s {\n", ns, fn.ReturnType)
	fmt.Fprintf(&b, "  return _data as %s.%s;\n", ns, fn.ReturnType)
	b.WriteString("}\n\n")

	// __setServerData() function
	b.WriteString("export function __setServerData(data: Record<string, any>) {\n")
	b.WriteString("  _data = data;\n")
	b.WriteString("}\n")

	return b.String()
}

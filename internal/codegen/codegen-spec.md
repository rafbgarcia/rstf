# Codegen Specification

## Overview

The codegen module produces all framework-generated files under `.rstf/`. It parses Go source files via AST, analyzes TypeScript imports for dependencies, and generates three categories of output:

1. **TypeScript types** (`.rstf/types/*.d.ts`) — global type declarations from Go structs
2. **Runtime modules** (`.rstf/generated/*.ts`) — `serverData()` + `__setServerData()` per component
3. **Server entry point** (`.rstf/server_gen.go`) — Go `main()` that wires routes, calls `SSR()` handlers, and sends render requests

## Generated output (`.rstf/` directory)

All framework-generated files go in `.rstf/`:

```
.rstf/
  server_gen.go              # Generated Go server with route handlers
  types/
    index.d.ts               # Global types for /
    dashboard.d.ts           # Global types for /dashboard
  generated/
    main.ts                  # Runtime module for layout
    routes/
      index.ts
      dashboard.ts
    shared/ui/
      user-avatar.ts
  entries/
    dashboard.entry.tsx      # Hydration entry for /dashboard
  static/
    main.css                   # Processed CSS (if main.css exists; generated by CLI)
    dashboard/bundle.js        # Hydration bundle (generated by esbuild)
```

## SSR function contract

- `SSR` must return a **single named struct**. Returning primitives, multiple values, or anonymous types is not valid.
- The first parameter can be `*rstf.Context` (any import alias). The framework detects and skips it in type generation.
- Only exported (capitalized) struct fields appear in TypeScript output.
- Only structs transitively referenced by the `SSR` return type are included.

## Type mapping

| Go type | TypeScript type |
|---------|-----------------|
| `string` | `string` |
| `int`, `float64`, etc. | `number` |
| `bool` | `boolean` |
| `[]T` | `T[]` |
| Named struct | Interface with same name |

Field names come from `json` struct tags. If no tag, the field name is lowercased. Fields tagged `json:"-"` are excluded.

## Namespace naming

The TypeScript namespace is derived from the directory path, PascalCased. Types are declared globally via `declare namespace` — no imports needed in components.

| Directory | Namespace |
|-----------|-----------|
| `.` (layout) | `Main` |
| `routes/dashboard/` | `RoutesDashboard` |
| `routes/settings/` | `RoutesSettings` |
| `shared/ui/user-avatar/` | `SharedUiUserAvatar` |

## `@rstf/` import alias

Components import server data via `@rstf/{path}`, where `{path}` matches the component's directory relative to the project root:

| Component | Import path | Resolves to |
|-----------|-------------|-------------|
| `main.tsx` | `@rstf/main` | `.rstf/generated/main.ts` |
| `routes/dashboard/index.tsx` | `@rstf/routes/dashboard` | `.rstf/generated/routes/dashboard.ts` |
| `shared/ui/user-avatar/index.tsx` | `@rstf/shared/ui/user-avatar` | `.rstf/generated/shared/ui/user-avatar.ts` |

The `tsconfig.json` `paths` mapping handles this for TypeScript. Bun respects `tsconfig.json` paths at runtime for SSR. esbuild auto-discovers `tsconfig.json` paths when bundling, so the same mapping works for client-side bundling.

## Generated runtime module format

Each generated module is dual-mode (server and client):

```typescript
let _data: Record<string, any> =
  typeof window !== "undefined"
    ? (window as any).__RSTF_SERVER_DATA__["routes/dashboard"] ?? {}
    : {};

export function serverData(): RoutesDashboard.ServerData {
  return _data as RoutesDashboard.ServerData;
}

export function __setServerData(data: Record<string, any>) {
  _data = data;
}
```

On the server, `_data` starts empty and is set by the sidecar before each render. On the client, `_data` initializes from `window.__RSTF_SERVER_DATA__` at import time. The key in `__RSTF_SERVER_DATA__` matches the component path (e.g. `"routes/dashboard"`, `"main"`).

## Static import analysis

The framework discovers which `.go` files to call per route by analyzing TSX imports at codegen time.

**Rules:**

- Only local relative imports (`./`, `../`) are followed. Bare specifiers (`react`, `@rstf/...`) are skipped.
- Only `.tsx` files are resolved (`.ts` files don't have `.go` pairings). Resolution tries `{specifier}.tsx` then `{specifier}/index.tsx`.
- Imports are scanned recursively with cycle detection (visited-files set).
- `main.go` is always included — the layout runs on every request.

**Output** — a dependency map of which `SSR()` functions to call per route:

```
GET /                -> [main, routes/index]
GET /dashboard       -> [main, routes/dashboard, shared/ui/user-avatar]
```

## Server generation (`server_gen.go`)

The generated server declares `package main` with `func main()`, imports the user's root package and all route/shared packages, and wires HTTP handlers using `github.com/rafbgarcia/rstf/router`. The router wraps chi internally and resolves ambiguous routes by left-to-right specificity (literal segments beat wildcards). A middleware bridges chi URL params to `Request.SetPathValue()` so user code continues to use `ctx.Request.PathValue("id")`. Chi is a transitive dependency — the user's `go.mod` only requires the framework itself.

**Rules:**

- User's `main.go` uses the app's package name (not `package main`), making it importable. See `internal/conventions/conventions-spec.md`.
- Layout `app.SSR()` is called on every request, before route-specific handlers.
- Each `SSR()` return struct is converted to `map[string]any` via JSON round-trip so keys match `json` tags.
- `ServerData` in render requests is keyed by component path (e.g. `"routes/dashboard"`). See `renderer/renderer-spec.md`.
- The server accepts `--port` flag (default `3000`), handles graceful shutdown (SIGINT/SIGTERM), and serves `.rstf/static/` for hydration bundles.
- Page assembly: wraps rendered HTML with `<!DOCTYPE html>`, injects optional `<link rel="stylesheet">` before `</head>` (if `.rstf/static/main.css` exists at server startup), and injects `__RSTF_SERVER_DATA__` script and hydration bundle script before `</body>`.
- Directories with `$` (dynamic segments) cannot be used directly as Go import paths. Codegen creates symlinks under `.rstf/pkgs/` with `$` stripped (e.g. `.rstf/pkgs/routes/sites.id` → `routes/sites.$id`) and imports those paths instead.

## Generator struct

A `Generator` struct persists state between codegen runs. Two entry points:

- **`Generate()`** — full pipeline (startup). Removes `.rstf/`, parses everything, writes all files, populates internal state.
- **`Regenerate(events)`** — incremental pipeline (file changes). Re-parses only changed Go directories, re-analyzes deps with a warm filesystem cache, diffs outputs, writes only what changed.

The standalone `Generate(projectRoot)` function is a wrapper that creates a throwaway Generator — existing tests and one-shot callers work without change.

### Regenerate logic

1. Classify events into Go-changed dirs and TSX-changed flag
2. Invalidate `fsCache` entries for changed paths
3. For each Go-changed dir: `ParseSingleDir` → update/remove from `filesByDir` → write DTS + runtime module
4. Rebuild files slice from `filesByDir`
5. Re-create `$` symlinks for changed dirs
6. Re-discover TSX-only routes
7. Re-run `AnalyzeDeps` for all routes (parallel, warm cache — fast because only invalidated entries re-read from disk)
8. Diff old vs new deps per route → only write hydration entries that changed
9. Generate `server_gen.go` content, compare with previous → write only if different, set `ServerChanged`
10. Update cached state

`RegenerateResult` extends `GenerateResult` with a `ServerChanged` bool so the caller knows whether to restart the Go server.

## Generation pipeline (full — Generate)

The pipeline parallelizes independent work across four phases:

**Phase 1 — sequential setup:**

1. Remove `.rstf/` (clean slate)
2. Parse all Go route files via AST (skips `.rstf/`, `.git`, `node_modules`, `vendor`)
3. Create `.rstf/` directory structure

**Phase 2 — parallel (all independent after Parse):**

4. Analyze TSX import dependencies per route (parallel, shared filesystem cache across routes)
5. Write `.d.ts` types and runtime modules for each component (parallel per file)
6. Create symlinks for directories with `$` in their names (see Server generation)

**Phase 3 — parallel (needs deps from Phase 2):**

7. Generate hydration entry files `.rstf/entries/` (parallel per route)

**Phase 4 — sequential finalization:**

8. Generate `server_gen.go`
9. Resolve framework dependencies via `go get` (skipped when developing the framework itself or when the framework module is already in `go.sum`) — `server_gen.go` lives in `.rstf/` (dot-prefixed, invisible to `go mod tidy`), so its transitive deps (e.g. chi via `rstf/router`) must be added to `go.sum` explicitly on first run

**Performance:** A shared `fsCache` avoids redundant file reads and directory listings when multiple routes import the same TSX files. The cache persists across `Regenerate` calls — only invalidated entries are re-read from disk. Concurrency is bounded by `runtime.NumCPU()`.

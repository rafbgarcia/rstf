# Codegen Specification

## What the developer writes

A route directory contains a Go file with structs and a handler function:

```
dashboard/
  dashboard.go
  dashboard.tsx
```

```go
package dashboard

import rstf "github.com/rafbgarcia/rstf"

type Post struct {
    Title     string `json:"title"`
    Published bool   `json:"published"`
}

type Author struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func SSR(ctx *rstf.Context) (posts []Post, author Author) {
    // fetch data, use ctx.Log, etc.
    return
}
```

## What the framework generates

### TypeScript types (`.rstf/types/dashboard.d.ts`)

The framework generates a `.d.ts` declaration file per route with a `declare namespace`. Types are globally available — no imports needed.

```typescript
// Code generated by rstf. DO NOT EDIT.

declare namespace Dashboard {
  interface Post {
    title: string;
    published: boolean;
  }

  interface Author {
    name: string;
    email: string;
  }

  interface SSRProps {
    posts: Post[];
    author: Author;
  }
}
```

### Namespace naming

The namespace is derived from the route directory path, PascalCased:

| Directory | Namespace |
|-----------|-----------|
| `dashboard/` | `Dashboard` |
| `settings/` | `Settings` |
| `users/profile/` | `UsersProfile` |

### How it works

1. The framework scans the directory for `.go` files.
2. It looks for exported functions with recognized names: `SSR`, `GET`, `POST`, `PUT`, `DELETE`.
3. For each function, it reads the **named return parameters** to determine the prop names and types.
   - `posts []Post` becomes `posts: Post[]`
   - `author Author` becomes `author: Author`
4. It resolves each referenced struct and maps Go types to TypeScript types:
   - `string` → `string`
   - `int`, `float64`, etc. → `number`
   - `bool` → `boolean`
   - Struct names are kept as-is (e.g. `Post` → `Post`)
   - Slices become arrays (e.g. `[]Post` → `Post[]`)
5. Field names come from `json` struct tags. If no tag exists, the field name is lowercased (`Title` → `title`). Fields tagged `json:"-"` are excluded.
6. Only structs referenced by route functions are included in the output.

### TypeScript configuration

`rstf init` creates a `tsconfig.json` that includes the types directory:

```json
{
  "include": [".rstf/types", "**/*.ts", "**/*.tsx"]
}
```

This makes all namespaced types globally available. The developer never imports them.

### Conventions

- **Named returns are required.** `func SSR() []Post` is ignored because there's no prop name. Write `func SSR() (posts []Post)` instead.
- **The first parameter can be `*rstf.Context`.** The framework detects this and skips it — it doesn't appear in the generated TypeScript. The import alias doesn't matter (`rstf`, `fw`, etc.).
- **Unexported struct fields are excluded.** Only exported fields (capitalized) appear in the TypeScript output.

### How the developer uses the generated types

```tsx
export function View({ posts, author }: Dashboard.SSRProps) {
  return (
    <div>
      <p>By {author.name}</p>
      {posts.map((post) => (
        <p>{post.title}</p>
      ))}
    </div>
  );
}
```

The props are type-checked against what the Go function returns. If the Go code changes (e.g. a field is renamed or a new return param is added), the `.d.ts` regenerates on the next codegen run, and the TSX component will show a type error if it doesn't match.

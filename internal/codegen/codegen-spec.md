# Codegen Specification

## Overview

The codegen module produces all framework-generated files under `.rstf/`. It parses Go source files via AST, analyzes TypeScript imports for dependencies, and generates three categories of output:

1. **TypeScript types** (`.rstf/types/*.d.ts`) — global type declarations from Go structs
2. **Runtime modules** (`.rstf/generated/*.ts`) — `serverData()` + `__setServerData()` per component
3. **Server entry point** (`.rstf/server_gen.go`) — Go `main()` that wires routes, calls `SSR()` handlers, and sends render requests

## Generated output (`.rstf/` directory)

All framework-generated files go in `.rstf/`:

```
.rstf/
  server_gen.go              # Generated Go server with route handlers
  types/
    index.d.ts               # Global types for /
    dashboard.d.ts           # Global types for /dashboard
  generated/
    main.ts                  # Runtime module for layout
    routes/
      index.ts
      dashboard.ts
    shared/ui/
      user-avatar.ts
  entries/
    dashboard.entry.tsx      # Hydration entry for /dashboard
  static/
    main.css                   # Processed CSS (if main.css exists; generated by CLI)
    dashboard/bundle.js        # Hydration bundle (generated by esbuild)
```

## SSR function contract

- `SSR` must return a **single named struct**. Returning primitives, multiple values, or anonymous types is not valid.
- The first parameter can be `*rstf.Context` (any import alias). The framework detects and skips it in type generation.
- Only exported (capitalized) struct fields appear in TypeScript output.
- Only structs transitively referenced by the `SSR` return type are included.

## Type mapping

| Go type | TypeScript type |
|---------|-----------------|
| `string` | `string` |
| `int`, `float64`, etc. | `number` |
| `bool` | `boolean` |
| `[]T` | `T[]` |
| Named struct | Interface with same name |

Field names come from `json` struct tags. If no tag, the field name is lowercased. Fields tagged `json:"-"` are excluded.

## Namespace naming

The TypeScript namespace is derived from the directory path, PascalCased. Types are declared globally via `declare namespace` — no imports needed in components.

| Directory | Namespace |
|-----------|-----------|
| `.` (layout) | `Main` |
| `routes/dashboard/` | `RoutesDashboard` |
| `routes/settings/` | `RoutesSettings` |
| `shared/ui/user-avatar/` | `SharedUiUserAvatar` |

## `@rstf/` import alias

Components import server data via `@rstf/{path}`, where `{path}` matches the component's directory relative to the project root:

| Component | Import path | Resolves to |
|-----------|-------------|-------------|
| `main.tsx` | `@rstf/main` | `.rstf/generated/main.ts` |
| `routes/dashboard/index.tsx` | `@rstf/routes/dashboard` | `.rstf/generated/routes/dashboard.ts` |
| `shared/ui/user-avatar/index.tsx` | `@rstf/shared/ui/user-avatar` | `.rstf/generated/shared/ui/user-avatar.ts` |

The `tsconfig.json` `paths` mapping handles this for TypeScript. Bun respects `tsconfig.json` paths at runtime for SSR. esbuild auto-discovers `tsconfig.json` paths when bundling, so the same mapping works for client-side bundling.

## Generated runtime module format

Each generated module is dual-mode (server and client):

```typescript
let _data: Record<string, any> =
  typeof window !== "undefined"
    ? (window as any).__RSTF_SERVER_DATA__["routes/dashboard"] ?? {}
    : {};

export function serverData(): RoutesDashboard.ServerData {
  return _data as RoutesDashboard.ServerData;
}

export function __setServerData(data: Record<string, any>) {
  _data = data;
}
```

On the server, `_data` starts empty and is set by the sidecar before each render. On the client, `_data` initializes from `window.__RSTF_SERVER_DATA__` at import time. The key in `__RSTF_SERVER_DATA__` matches the component path (e.g. `"routes/dashboard"`, `"main"`).

## Static import analysis

The framework discovers which `.go` files to call per route by analyzing TSX imports at codegen time.

**Rules:**

- Only local relative imports (`./`, `../`) are followed. Bare specifiers (`react`, `@rstf/...`) are skipped.
- Only `.tsx` files are resolved (`.ts` files don't have `.go` pairings). Resolution tries `{specifier}.tsx` then `{specifier}/index.tsx`.
- Imports are scanned recursively with cycle detection (visited-files set).
- `main.go` is always included — the layout runs on every request.

**Output** — a dependency map of which `SSR()` functions to call per route:

```
GET /                -> [main, routes/index]
GET /dashboard       -> [main, routes/dashboard, shared/ui/user-avatar]
```

## Server generation (`server_gen.go`)

The generated server declares `package main` with `func main()`, imports the user's root package and all route/shared packages, and wires HTTP handlers using `github.com/rafbgarcia/rstf/router`. The router wraps chi internally and resolves ambiguous routes by left-to-right specificity (literal segments beat wildcards). A middleware bridges chi URL params to `Request.SetPathValue()` so user code continues to use `ctx.Request.PathValue("id")`. Chi is a transitive dependency — the user's `go.mod` only requires the framework itself.

**Rules:**

- User's `main.go` uses the app's package name (not `package main`), making it importable. See `internal/conventions/conventions-spec.md`.
- Layout `app.SSR()` is called on every request, before route-specific handlers.
- Each `SSR()` return struct is converted to `map[string]any` via JSON round-trip so keys match `json` tags.
- `ServerData` in render requests is keyed by component path (e.g. `"routes/dashboard"`). See `renderer/renderer-spec.md`.
- The server accepts `--port` flag (default `3000`), handles graceful shutdown (SIGINT/SIGTERM), and serves `.rstf/static/` for hydration bundles.
- Page assembly: wraps rendered HTML with `<!DOCTYPE html>`, injects optional `<link rel="stylesheet">` before `</head>` (if `.rstf/static/main.css` exists at server startup), and injects `__RSTF_SERVER_DATA__` script and hydration bundle script before `</body>`.
- Directories with `$` (dynamic segments) cannot be used directly as Go import paths. Codegen creates symlinks under `.rstf/pkgs/` with `$` stripped (e.g. `.rstf/pkgs/routes/sites.id` → `routes/sites.$id`) and imports those paths instead.

## Generation pipeline

1. Remove `.rstf/` (clean slate)
2. Read module path from `go.mod`
3. Discover all Go files with `SSR` functions via AST parsing (skips `.rstf/`)
4. Analyze TSX import dependencies per route
5. Create symlinks for directories with `$` in their names (see Server generation)
6. Write `.d.ts` types and runtime modules for each component
7. Generate hydration entry files (`.rstf/entries/`)
8. Generate `server_gen.go`
9. Resolve framework dependencies via `go get` (skipped when developing the framework itself or when the framework module is already in `go.sum`) — `server_gen.go` lives in `.rstf/` (dot-prefixed, invisible to `go mod tidy`), so its transitive deps (e.g. chi via `rstf/router`) must be added to `go.sum` explicitly on first run

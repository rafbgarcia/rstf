# Codegen Specification

## What the developer writes

A route directory contains a Go file with structs and a handler function:

```
dashboard/
  dashboard.go
  dashboard.tsx
```

```go
package dashboard

import rstf "github.com/rafbgarcia/rstf"

type Post struct {
    Title     string `json:"title"`
    Published bool   `json:"published"`
}

type Author struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type ServerData struct {
    Posts  []Post `json:"posts"`
    Author Author `json:"author"`
}

func SSR(ctx *rstf.Context) ServerData {
    // fetch data, use ctx.Log, etc.
    return ServerData{}
}
```

The `.go` file is optional — a `.tsx` file can exist without a paired `.go` file (for pages with no server data).

## What the framework generates

### TypeScript types (`.rstf/types/dashboard.d.ts`)

The framework generates a `.d.ts` declaration file per route with a `declare namespace`. Types are globally available — no imports needed.

```typescript
// Code generated by rstf. DO NOT EDIT.

declare namespace Dashboard {
  interface Post {
    title: string;
    published: boolean;
  }

  interface Author {
    name: string;
    email: string;
  }

  interface ServerData {
    posts: Post[];
    author: Author;
  }
}
```

### Generated runtime module (`.rstf/generated/dashboard.ts`)

Alongside the type declarations, codegen generates a runtime module that the component imports at runtime via `@rstf/dashboard`:

```typescript
// .rstf/generated/dashboard.ts (generated — do not edit)
let _data: Record<string, any> = {};

export function serverData(): Dashboard.ServerData {
  return {
    posts: _data.posts ?? [],
    author: _data.author ?? {},
  } as Dashboard.ServerData;
}

export function __setServerData(data: Record<string, any>) {
  _data = data;
}
```

The `serverData()` function returns the current request's data. Components call it inside their `View` function. The `__setServerData()` function is internal — called by the Bun sidecar before each render.

### Namespace naming

The namespace is derived from the route directory path, PascalCased:

| Directory | Namespace |
|-----------|-----------|
| `dashboard/` | `Dashboard` |
| `settings/` | `Settings` |
| `users/profile/` | `UsersProfile` |

### How it works

1. The framework scans the directory for `.go` files.
2. It looks for an exported `SSR` function.
3. `SSR` must return a single struct type. The struct's fields become the server data shape.
4. It resolves each referenced struct and maps Go types to TypeScript types:
   - `string` → `string`
   - `int`, `float64`, etc. → `number`
   - `bool` → `boolean`
   - Struct names are kept as-is (e.g. `Post` → `Post`)
   - Slices become arrays (e.g. `[]Post` → `Post[]`)
5. Field names come from `json` struct tags. If no tag exists, the field name is lowercased (`Title` → `title`). Fields tagged `json:"-"` are excluded.
6. Only structs referenced by the `SSR` function's return type are included in the output.

### TypeScript configuration

`rstf init` creates a `tsconfig.json` that includes the types directory:

```json
{
  "include": [".rstf/types", "**/*.ts", "**/*.tsx"]
}
```

This makes all namespaced types globally available. The developer never imports them.

### Conventions

- **`SSR` must return a single struct.** `func SSR() string` or `func SSR() (posts []Post, author Author)` are not valid. The return type must be a named struct (e.g. `ServerData`) whose fields define the data shape.
- **The first parameter can be `*rstf.Context`.** The framework detects this and skips it — it doesn't appear in the generated TypeScript. The import alias doesn't matter (`rstf`, `fw`, etc.).
- **Unexported struct fields are excluded.** Only exported fields (capitalized) appear in the TypeScript output.

### How the developer uses the generated types

```tsx
import { serverData } from "@rstf/dashboard";

export function View() {
  const { posts, author } = serverData();
  return (
    <div>
      <p>By {author.name}</p>
      {posts.map((post) => (
        <p>{post.title}</p>
      ))}
    </div>
  );
}
```

The `serverData()` return type matches the `ServerData` struct. If the Go code changes (e.g. a field is renamed or a new field is added), the `.d.ts` and generated module regenerate on the next codegen run, and the TSX component will show a type error if it doesn't match.
